# Linux

# 计算机概论
+ 文件大小使用**二进制**，速度单位使用**十进制**
1. 文件大小：1 KB = 1024 B = 2^10 B
2. 速度单位：1 Mbit/s = 1 * 1000 * 1000 bit/s
+ CPU 外频和倍频
1. **外频**：cpu与外部组件进行数据传输/运算时的速度。
2. **倍频**：CPU内部用来加速工作性能的一个**倍数**。
3. CPU频率 = 外频 * 内频
+ 32位和64位
1. 术语叫**字组大小**
2. 代表一次可以在内存寻址的范围：32位 ➡️  2^32 ➡️  2^2 * 2^10 * 2^10 * 2^10 ➡️  4G, 32位的CPU最多只能支持4G的内存，多了没用。
+ CMOS和BIOS
1. CMOS类似内存，是**存储器**，需要有电源支持，主要纪录主板上面的重要参数（系统时间、CPU电压与频率、各项设备的I/O地址与IRQ等）
2. BIOS是**程序**，加载CMOS中的参数，调用存储设备中的开机程序，进入操作系统中。
+ 系统调用
1. 应用程序和操作系统内核之间的接口，使得应用内程序可以在内核上运行。
2. 根据某一系统调用开发的应用程序无法在其他操作系统上运行。（Linux和Windows软件区别）
+ 驱动程序
1. 操作系统提供接口给硬件开发商，开发商要去实现这些接口开发驱动程序。
2. 什么意思呢？就是说操作系统告诉硬件开放商要实现哪些接口，之后直接以接口变量的形式调用这些功能，驱动程序相当于实现了那些接口的具体类，操作系统无需关心具体类是什么，只关心有什么接口，直接调用即可。
# Linux思想
+ Linux一切皆文件。
# 磁盘分区
+ IDE接口
1. IDE接口有两个：IDE1(Primary),IDE2(Secondary)，每个接口可以连接2个IDE设备，一共可以连接4个IDE设备。
2. 设备文件名与接口**物理位置**绑定：
    + IDE1-Primary(Master):/dev/hda
    + IDE1-Secondary(Slave) /dev/hdb
    + IDE2-Primary(Master):/dev/hdc
    + IDE2-Secondary(Slave) /dev/hdd
+ SATA接口
1. 设备文件名**以Linux内核检测到的顺序**决定，**与插槽的物理位置无关**。 如：/dev/sda;/dev/sdb...
+ 磁盘组成
1. 磁盘扇区大小固定（512Bytes）
2. 整块磁盘第一块扇区纪录了两个重要信息
    + 主引导分区（Master Boot Record,MBR）,可以存储**引导加载程序**，有446bytes。**系统开机的时候会主动去读取这个区块的内容**
    + 分区表，纪录整块硬盘分区的状态，有64bytes。
+ 磁盘分区表
1. 设备文件名后会再接一个**数字**，这个数字表示了**分区位置**（/dev/hda1）
2. “分区”是对64bytes的分区表进行设置
3. 分区表仅能写入**4组**分区信息(主分区Primary与扩展分区Extended一共最多有4个，扩展分区最多占其中1个)
4. 逻辑分区是由扩展分区持续切割出来的分区。**逻辑分区只能从5号开始标识（/dev/hda5）**，哪怕2、3、4号都没有被占用。
5. 分区的最小单位是柱面（cylinder），一个或多个柱面组成一个分区。
6. IDE硬盘最多有59个逻辑分区（5号到63号），SATA硬盘最多有11个逻辑分区（5号到15号）
+ 开机流程与主引导分区(MBR)
1. BIOS：开机主动执行的韧体，会认识**第一个可开机的设备**
2. MBR：第一个可开机设备的第一个扇区的主引导分区块，内含**引导加载程序（Boot loader）**
3. **引导加载程序（Boot loader）**：一支可读取内核文件来执行的**软件**。
4. 内核文件：开始操作系统的功能。
+ 多重引导（Linux/Windows双系统）
1. 引导加载程序可以将引导功能转交给其他loader负责（boot sector）
2. MBR中的引导加载程序可以提供两个菜单：一个直接加载Windows内核文件，一个是将引导加载工作交给**另一个分区的启动扇区（boot sector）**。
3. 选择第二个菜单时，引导加载工作就交个另一个分区的引导加载程序。
4. 总结
    + 每个分区都拥有自己的启动扇区（boot sector）
    + 实际可开机的内核文件是存放在各分区的
    + loader只会认识自己的系统分区内的可开机内核文件和其他loader
    + loader可直接指向或者是间接将管理权转交给另一个管理程序
5. 如果要安装多重引导，最好先安装Windows再安装Linux：Windows在安装的时候，安装程序会主动覆盖掉MBR以及自己所在分区的启动扇区。Linux则允许在Linux的boot loader里面加入Windows选项。
+ 文件系统与目录树的关系（**挂载**）
1. 挂载是利用一个目录设置一个**进入点**：通过这个进入点进入这个磁盘分区，磁盘分区的数据放置在该目录下。
2. **partition1**挂载在根目录/，**partition2**挂载在/home。所以/home内各**次目录**的数据都是放在partition2的，如果不是放在/home下面的目录，则数据放在partition1。
3. **挂载只对应目录**，不对应文件。
# 基础操作
+ 显示日期的命令：date
1. date +%Y/%m/%d 
2. date +%H:%M
+ 重要的热键
1. [Tab]  命令补全，文件补齐
2. [Ctrl]-c 终端目前程序的按键
3. [Ctrl]-d 键盘输入结束（End Of File 或 End Of Input）
+ 在线求助 man命令
1. man 7 ${command} 获得详细的说明
2. 向下翻页：空格键、[Page Down]
3. 向上翻页：[Page Up]
4.  去到第一页：[Home]
5.  去到最后一页：[End]
6.  向下查询string字符串：/string；用n键继续字符串的下一个查询
7.  向上查询string字符串：?string；用N键继续字符串的上一个查询
8.  退出：q
+ 正确关机
1. 数据同步写入磁盘：sync；将内存尚未被更新的数据写入硬盘，系统关机或重启之前最好多执行几次
2. 重启、关机命令
    + 以下命令在执行前都会进行sync命令的调用
    + `sync;sync;sync;reboot`
    + `shutdown -h now`
    + `poweroff -f`
3. 切换执行等级init
    + Linux**系统运作的模式**共有7种
        + run level 0:关机
        + run level 3：纯命令行模式
        + run level 5：含有图形界面模式
        + run level 6：重启
    + 关机命令 `init 0`
# Linux的文件权限与目录配置
+ /etc/passwd：系统上的所有账号、一般身份用户和root用户的相关信息
+ /etc/shadow：个人的密码
+ /etc/group：Linux所有的组名
+ list查看文件信息
1. 第一列代表文件的类型与权限
    + [d]目录、[-]文件、[l]连接文件、[b]块存储设备、[c]串行端口设备，如键盘鼠标
    + [r]可读、[w]可写、[x]可执行
    + 3个一组，第一组为**文件所有者的权限**，第二组为**同属一个用户组的权限**，第三组为**其他非本用户组的权限**
2. 第二列表示有多少文件名连接到此节点（i-node）
    + i-node纪录文件的权限和属性，一个i-node可以纪录多个不同文件名。
    + 这个数字表明有多少不同的文件名连接到相同的一个i-node号码
3. 第三列表示这个文件（或目录）的“所有者”账号名
4. 第四列表示这个文件的所属用户组名
5. 第五列表示这个文件的**容量**大小（**能容纳的数据量**），默认单位为B。
6. 第六列表示文件的创建日期或最新一次的修改日期。（`ls -l --full-time`）
7. 第七列为该文件名
+ 改变文件属性与权限
1. chgrp：改变文件所属用户组， -R 进行递归更改，连同子目录下所有文件、目录
2. chown：改变文件所有者，-R 同上
3. chmod：改变权限
    + r:4
    + w:2
    + x:1
    + u（user）、g（group）、o（others）、a（all）
    + +（加入）、-（除去）、=（设置）
+ 文件权限与目录权限的关系
1. 拥有对**文件**的写权限(w)并**不具备删除**该文件的权限。rwx都是针对**文件内容**而言。
2. 拥有对**目录**的写权限(w)表明可以**更改目录结构**，意味着：
    + **可以删除**该目录下的文件或目录（不论该文件的权限为何）
    + 新建新的文件与目录
    + 将已存在的文件或目录重命名
    + 转移该目录内的文件、目录位置
3. 拥有对**目录**的执行权限(x)表明**用户可以进入该目录成为工作目录**，即可以**使用`cd`命令进入**。
+. Linux亩配置**标准**：FHS
1. /usr 软件放置处
2. /etc 配置文件
3. /lib 执行文件所需的函数库与内核所需的模块
4. /boot 开机与内核文件
5. /dev 设备文件
6. /proc 虚拟文件系统，表示内存数据
7. /sys 虚拟文件系统，记录与内核相关的信息
8. /sbin /bin 重要执行文件
+ 网络上的文件系统也可以挂载本地目录，例如：NFS服务
+ 绝对路径与相对路径
1. 绝对路径：由根目录(/)开头的路径
2. 相对路径：以当前所在路径的相对位置来表示
    + `.` :表示当前目录，同 `./`
    + `..` :表示上一层目录，同 `../`
# Linux文件与目录管理
+ 特殊目录
1. `.`  代表当前目录 
2. `..` 代表上一层目录
3. `\-`  代表前一个**工作目录**（**执行`cd`命令前的目录**）
4. `~`  代表**目前用户身份**所在的**主文件夹**
5. `~account` 代表**account**这个用户所的**主文件夹**
+ 常见目录处理命令
1. cd：切换目录
2. pwd：显示当前目录
3. mkdir：新建一个新的目录
    + -p : 自动创建不存在的目录 mkdir -p /home/user1/test1 
4. rmdir：删除一个**空**的目录（即目录下有文件就执行不了）
+ 执行文件路径的变量：**$PATH**
1. 执行命令时，系统会依照PATH的设置去**每个PATH定义的目录**下查询文件名为该命令的可执行文件，如果在PATH定义的目录中含有多个相同名字的可执行文件，那么**先查询到的同名命令先被执行**。
2. PATH（**一定是大写**），变量内容是一堆目录，每个目录用冒号（:）隔开，每个目录是有**顺序**之分的。
3. 安全起见，不建议将 . 加入PATH的查询目录中。
+ 文件与目录管理
1. ls：查看文件与目录 `ls -al` `ll` `ls --full-time` `ls --time=atime` `ls --time=ctime`
    + \-a: 显示全部文件，连同隐藏文件（开头为 . 的文件）。
    + \-d：仅列出目录
    + \-l：列出文件属性与权限等数据
    + \-r：排序结果反向输出
    + \-R：子目录递归输出
    + \-S：以文件**容量**大小排序
    + \-t：以时间排序
2. cp：复制文件 `cp -a source destination`
    + 复制文件需要有**read权限**
    + 默认条件中，cp的源文件与目的文件的**权限是不同的**，目的文件的**所有者**通常会是命令操作者本身。
    + \-a：等于 \-pdr
    + \-d：若源文件为连接文件，则复制连接文件属性而非文件本身
    + \-p：连同文件的属性一起复制过去
    + \-r：递归持续复制
    + cp /dir1/file1 /dir2： dir1至少需要x权限，file1至少需要r权限，dir2至少需要w、x权限。         
3. 软连接与硬链接（更详细信息见后续相关章节）
    + 软连接（symbolic link）相当与快捷方式，删除**被链接的源文件**会导致无法访问。
    + 硬链接（hard link）相当与直接关联源文件的存储区块，本质上关联与源文件相同的i-node（所以权限参数中会有i-node关联数），**直接删除仍有源文件**。
4. rm：移除文件或目录 `rm -f` `rm -rf` 
    + \-f：强制删除force
    + \-r：递归删除
5. mv：移动文件与目录，或**更名** `mv old new`
    + rename同样可以更名
6. basename：取得路径的文件名与目录名称 `basename path` `dirname path`
    + basename 取得路径的最后一项 basename /etc/sysconfig/network  ➡️  network
    + dirname 除去路径的最后一项剩下的 dirname /etc/sysconfig/network ➡️  /etc/sysconfig
    + 一般在写程序的时候使用
+ 文件**内容**查阅
1. cat：由第一行开始显示内容 `cat -n` `cat -b` `cat -E` `cat -A` 
    + \-n：显示行号，空白行也标行号
    + \-b：显示行号，空白行不标行号
    + \-E：将结尾的断行字符$显示出来
    + \-A：等于 \-vET
    + \-v：列出一些看不出来的特殊字符
    + \-T：将[Tab]键以 ^I 显示出来
2. more：翻页查看（**只能向后**）
    + 空格键（Space）：向下翻**一页**
    + Enter：向下滚动**一行**
    + /string：查询字符串关键字，n键向下继续查询
    + \:f：显示文件名和行数
    + q：退出
    + b或[Ctrl]-b：往回翻页
3. less：翻页查看（**支持向前向后**）
    + 空格键（Space）/[PageDown]：向下翻**一页**
    + [PageUp]：向上翻一页
    + /string：**向下**查询字符串关键字
    + ?string：**向上**查询字符串关键字
    + n：重复前一个查询（与/或?定下的方向相关）
    + N：**反向**前一个查询（与/或?定下的方向相关）
    + q：退出
+ 数据选取
1. head：取出前面几行 `head -n 100` `head -n -100`
    + **负数**指**扣掉**文件*末尾*的100行，只取剩下的前面的所有数据行。  
2. tail：取出后面几行 `tail -n 100` `tail -n +100` `tail -f log.txt`
    + **正数**指第100行**以后**的所有数据
    + \-f：监测日志文件，**常用于查看是否有请求打进来**。
3. od：非纯文本文件（如二进制文件binary） `od -t c /usr/bin/passwd`
+ 文件时间
1. mtime：内容数据更改时间
2. ctime：文件状态（权限、属性等等）更改时间
3. atime：文件内容被取用时间，读取时间。（cat命令会更新这个时间） 
4. touch：修改文件时间或**创建新文件** `touch newfile.txt` `touch -a` `touch -c` `touch -m` 
+ 文件与目录的**默认权限**与**隐藏属性**
1. chattr设置，lsattr查看，只在**Ext2/Ext3**的文件系统上生效
2. umask：设置文件默认权限 `umask 022`
    + 文件默认权限 rw-rw-rw- 666
    + 目录默认权限 rwxrwxrwx 777
    + umask指的是默认值需要**减掉**的权限
    + 新建文件：rw-rw-rw-(666) **-** ----w--w-(022) ➡️ rw-r--r--(644)
    + 新建目录：rwxrwxrwx(777) **-** ----w--w-(022) ➡️ rwxr-xr-x(755)
3. chattr：设置文件的隐藏属性（**很多只能是root才能设置**）`chattr +a` ` chattr -a` `chattr +i` `chattr -i`
    + a 文件只能增加数据，不能删除和修改数据
    + i 文件不能删除、改名、设置连接、修改数据等等，直接锁死
+ 文件特殊权限
1. Set(Share) UID 4
    + 仅对**二进制程序**有效
    + **s标志**出现在文件**所有者**的**x权限**上
    + **非文件所有者**对该文件拥有**x权限**
    + 非文件所有者执行该文件时（run-time）将拥有文件所有者的权限。**s有share权限的意味**
2. Set(Share) GID 2
    + 仅对**二进制程序**有效
    + **s标志**出现在文件**文件所属用户组**的**x权限**上
    + **非文件所有者**对该文件拥有**x权限**
    + 非文件所有者执行该文件时（run-time）将获得**文件所属用户组的支持**。**s有share权限的意味**
3. Sticky Bit 1
    + 只针对**目录**有效
    + 用户对目录**拥有w，x权限**
    + **只能针对自己创建的文件或目录进行删除、重命名、移动等操作，无法删除他人文件。**
4. 通过chmod命令更改，在之前的三个数字前**再加上一个数字**，该数字代表特殊权限。 `chmod 6755 test` 
+ 查看文件类型
    1. file：`file /usr/bin/passwd`
+ 寻找“执行文件”
    1. which：默认查找PATH内所规范的目录 `which cd`
+ 文件名的查找
1. 通常先使用`whereis`或者`locate`来检查，速度更快，查不到了再用`find`
2. `whereis`和`locate`查找**数据库/var/lib/mlocate**，`find`查找硬盘
3. 更新locate数据库命令 `updatedb`
4. find：`find / -name passwd` `find /var -type f` `find / -perm 555` `find / -size +1000k` `find ./ -name "*.log" -exec rm -rf {}\;` `find / -atime +4`
    + \-exec：对查找结果进行**额外动作**，`{}`表示其中查找结果中的一条纪录，必须以`\;`结尾
# linux磁盘与文件系统管理
+ 文件系统的运行：
1. super block：纪录此文件系统的**整体信息**，包括index/block的总量、使用量、剩余量，以及文件系统的格式与相关信息等。
2. i-node：记录文件的**属性**，一个文件占用一个i-node，同时记录此文件的**数据所在的block号码**；
3. block：实际记录文件的内容，若文件太大时，会占用多个block。
4. 如果能找到文件的i-node的话，就能知道这个文件所放置的block号码，就能读出该文件的实际数据了。
5. Ext2为索引式文件系统。
6. FAT格式文件系统（U盘、闪存）**没有i-node存在**，每个block号码都记录在前一个block当中，类似链表，读取效率差，会导致**磁盘碎片**
+ Ext2文件系统
1. data block
    + 大小有：1KB 2KB 4KB
    + 文件大小大于block的大小，则一个文件会占用多个block数量
    + 文件大小小于block的大小，则该block剩余空间就不能够再被利用（**磁盘空间浪费**）
    + block的大小和数量在格式化完就不能再改变（除非重新格式化）
2. i-node table
    + 每个i-node大小均固定为 **128bytes**
    + 记录一个block号码要花费**4bytes**
3. i-node/block与**文件大小**的关系
    + 一个i-node分为**4个区域**（以1KB的block为例）
        + 12个**直接记录区**：直接记录12个block号码。12 * 1KB = 12KB
        + 1个**间接记录区**：记录1个block号码，这个block再去记录block号码。 1 * (1KB/4B) * 1KB = 256KB
        + 1个**双间接记录区**：记录1个block号码，这1个block的数据依然是block号码，再往下的block依然记录的是block号码。1 * (1KB/4B) * (1KB/4B) * 1KB = 256 * 256 KB
        + 1个**三间接记录区**: 记录1个block号码，这1个block的数据依然是block号码，再往下的block依然记录的是block号码，再再往下的block依然记录的是block号码。1 * (1KB/4B) * (1KB/4B) * (1KB/4B) * 1KB = 256 * 256 * 256 KB
        + 总额：12 + 256 + 256 * 256 + 256 * 256 * 256 = 16GB，所以如果将data block设置成1KB的话，文件系统能够容纳的**最大文件**为16GB。 
4. dumpe2fs：查看设备的文件系统信息 `dumpe2fs /dev/hdc2`
5. df：调出目前挂载的设备 `df -h` `df -h /` 
+ 文件系统的简单操作
1. df：列出文件系统的整体磁盘使用量 `df -h /etc` `df -i`
    + /proc挂载在内存当中，没有占据任何硬盘空间
    + /dev/shm 是**利用内存虚拟出来的磁盘空间**，这个目录下的任何数据文件的**访问速度非常快速**（在内存工作），**断电**后内容会消失
2. du：评估文件系统的磁盘使用量（常用于评估目录）`du -sh /etc` `du -m`
+ 连接文件：ln `目标文件连接源文件`
1. 硬链接（hard link） `ln 源文件 目标文件`
    + 新建一个文件名连接到某一个i-node上，不会增加i-node，也不会耗用block数量
    + 如果你将任何一个“文件名”删除，其实i-node与block**都还是存在的**，此时可以通过另一个“文件名”来读取到正确的文件数据
2. 软链接（Symbolic link） 符号链接，也即快捷方式 `ln -s 源文件 目标文件` 
    + symbolic link是创建一个**独立的文件**，指向**它链接的那个文件的文件名**
    + 当源文件被删除之后，symbolic link文件会**“无法打开”**
    + symbolic link所创建的文件为一个独立的新的文件，会**占用掉i-node与block**
+ 磁盘的分区、格式化、检验与挂载
1. 向系统新增硬盘的流程
    + 对磁盘进行分区，以新建可用分区
    + 对*该分区*进行格式化（format），以创建系统可用的文件系统
    + 对刚才新建好的文件系统进行检验
    + 在Linux系统上，创建挂载点（也即目录），并将它挂载上来
2. fdisk：**磁盘分区**，**只有root权限**才可以执行，设备名**不带数字**。 `fdisk /dev/hdc` `fdisk -l /dev/hdc 该命令仅查看信息，不操作磁盘` `partprobe`
    + m：命令介绍
    + d：删除一个分区
    + n：新增一个分区
    + p：显示分区表
    + q：退出，之前的所有操作**都不生效**
    + w：写入分区表，之前的所有操作**都生效**
    + **partprobe** w后要强制让**内存**更新分区表。
3. mkfs：进行**文件系统的格式化**，设备名**带数字**，表示对某一分区格式化文件系统。 `mkfs -t ext3 /dev/hdc6`
4. mke2fs：可以制定blcok大小和i-node数量,设备名**带数字**。`mke2fs -j -L "test" -b 2048 -i 8192 /dev/hdc6`
5. fsck,badblocks：**磁盘检验**，设备名**带数字** `fsck -C -f -t ext3 /dev/hdc6` `badlocks -sv /dev/hdc6`
6. mount,umount：**磁盘挂载与卸载**，设备名**带数字** `mount -a` `mount /dev/hdc6 /home/elesev` `mount -l` `umount /home/elesev` `umount /dev/hdc6` `mount -L "elesev" /home/elesev`
    + 单一文件系统不应该被重复挂载在不同的挂载点（目录）
    + 单一目录不应该重复挂载多个文件系统
    + 作为挂载点的目录理论上应该都是**空目录**
    + \-a：依照配置文件/etc/fstab的数据将所有未挂载的磁盘都挂载上来
    + \-l：显示目前挂载的信息
    + \-L：利用**卷标名称**进行挂载
7. e2label：设置**文件系统卷标**（Lable）`e2label /dev/hdc6 "elesev"`
+ 开机挂载
1. 关机后**挂载失效**，开机后系统**自动进行挂载**。
2. /etc/fstab(file system table)是mount命令执行时，所有参数会写入的文件。
3. 每次开机会根据/etc/fstab中的配置自动进行挂载，可以**直接编辑**此文件。
4. /etc/fstab输入有误导致无法开机成功，进入**单用户维护模式**。 使用命令`mount -n -o remount,rw /`，再重新编辑/etc/fstab
+ 内存交换空间（swap）的构建 `mkswap /dev/hdc7` `free -h` `free -m` `swapon /dev/hdc7` 
1. swap是**利用硬盘**来暂时存放**内存**中的信息。
2. swapon 启用内存交换空间
3. 最多创建32个swap
4. 64位最大内存寻址到64GB，swap总量最大也是仅能达64GB。
# 文件与文件系统的压缩与打包（文件系统也可以打包）
+ tar 
1. `tar -vtf` 
2. `tar -xvzf  -C ` 
3. `tar -czvf `
4.  `tar -czvf --exclude= `
+ dump：完整备份工具
1. `dump -S /dev/hdc1`
2. `dump -W`
3. `dump -0j -f /root/etc.dump.bz2 /etc`
+ restore：恢复数据
1. `restore -t -f /root/boot.dump`
+ dd：读取磁盘设备的内容，将整个设备备份成一个**文件**。
1. `dd if="input file" of="output file" bs="blocksize"`
2. `dd if=/etc/passwd of = /tmp/passwd.back`
3. `dd if=/dev/zero of=/tmp/elesev bs=1M count=128`
# Linux账号管理与ACL权限设置（未完成）
# 软件磁盘阵列（Software RAID）（未完成）
# 逻辑卷管理器（Logical Volume Manager）（未完成）
# 例行性工作（crontab）（未完成）
# 程序管理与SELinux初探
+ for-and-exec流程
1. 系统先以fork的方式复制一个与父进程相同的**暂存进程**，这个进程与父进程**唯一的区别**就是PID不同。
2. 这个暂存进程还会多一个**PPID参数（父进程的进程标识符）**
3. 然后暂存进程以exec的方式加载实际要执行的程序。
+ 服务（daemon）：常驻在内存当中的进程
+ **工作管理（job control）**
1. 进行工作管理的行为中，每个工作都是**目前bash的子进程**，彼此之间是有相关性的。
2. &：直接将命令丢到后台中“执行”
    + 这样不会被[Ctrl]+c中断，一定会执行
    + 后台执行的命令，如果有stdout和stderr，依然是输出到屏幕上面，由于无法用[Ctrl]+c中断，很有可能导致屏幕被搞得花花绿绿的，此时用数据流重定向，将输出数据传送至某个文件中。`tar -czvf /tmp/etc.tgz /etc > /tmp/log.txt 2>&1 &`
3. [Ctrl]+z：将目前的工作丢到后台中“暂停”
4. jobs：查看目前的后台工作状态
    + +：表示最近放到后台的工作号码，fg会先处理这个
    + -：表示最近最后第二个放置到后台的工作号码
5. fg(fore ground):将后台工作**拿到前台**来处理 `fg %1 工作号码为1的取出到前台处理`
6. bg：让工作在**后台下**的状态变成执行中 `bg %3`
+ kill：管理后台的工作 `kill -9 ${pid}` `kill -9 %2` `kill -SIGTERM %1`
1. -9：**强制删除**一个不正常的工作
2. -15：以**正常步骤**结束一项工作（15是默认值）
+ 脱机管理问题（退出bash后，任务会被中断掉）
1.nohup：脱机或注销系统后，工作继续进行。 `nohup ./tesh.sh &`
+ 进程的查看
1. ps：将某个时间点的进程运行情况选取下来
    + `ps -l`：仅查看自己的bash相关进程
        + F:4(root) 1(此子进程仅可进行复制fork而无法实际执行exec）
        + S：进程状态（STAT）
            + R(Running)：进程正在运行
            + S(Sleep)：进程处于睡眠状态，但可以被**唤醒**
            + D：不可以被唤醒，可能在等待I/O
            + T：停止状态，可能在工作控制（后台暂停）或除错（trace）状态
            + Z(Zombie)：进程已经终止，却无法被**删除至内存外**。
        + UID/PID/PPID：编号
        + C：CPU使用率，单位为百分比
        + PRI/NI：Priority/Nice缩写，CPU执行优先级，数值越小表示该进程越快被CPU执行
        + ADDR/SZ/WCHAN：都与内存有关
        + TTY：登陆者的终端机位置
        + TIME：**使用掉**的CPU时间，即此进程实际**花费CPU运行的时间**，不是系统时间
        + CMD：触发进程的命令
    + `ps aux`：查看系统所有进程，默认按照PID的顺序排序显示
        + USER：进程所属用户
        + PID：进程标识符
        + %CPU：使用掉的CPU资源百分比
        + %MEM：所占用的**物理内存**百分比
        + VSZ：使用掉的**虚拟内存量**（KB）
        + RSS：占用的**固定内存量**（KB）
        + TTY：终端机
        + STAT：进程状态（R/S/T/Z）
        + START:进程被触发启动的时间
        + TIME：进程**实际使用**CPU运行的时间
        + COMMAND：进程的实际命令
2. top：持续监测进程运行的状态（实时）
    + load average：系统在1,5,15分钟的**平均工作负载**。
    + 默认使用CPU使用率（%CPU）作为排序
    + M键 按照内存使用率排序
    + 1键 显示所有CPU核心
    + r键 修改nice指
 3. pstree：显示进程树
    + 所有的进程都是依附在**init进程**下面，这个进程的**PID是1号**，是由Linux内核主动调用的第一个进程。
 4. kill：管理进程，帮助我们将signal传送给**某个工作（%jobnumber）**或者是**某个PID（直接输入数字）** `kill -SIGKILL %1` `kill -SIGKILL 12345`
    + SIGHUP 1：让PID重新读取自己的配置文件，类似重新启动
    + SIGINT 2：相当于[Ctrl]-c，中断一个进程的进行
    + SIGKILL 9：强制中断一个进程
    + SIGTERM 15：以正常的结束进程来终止该进程
    + SIGSTOP 17：相当于[Ctrl]-z，暂停一个进程的进行
5. killall：通过**命令名称**发送信号，不需要查找PID或%jobnumber。`killall -1 httpd` `killall -9 httpd`        
+ 僵尸进程
1. 某个进程的CMD后面还街上< defunct > ，代表该进程是僵尸进程
2. 成因：进程已经执行完毕，或者因故应该要终止了，父进程却无法完整将该进程结束掉，造成进程一直存在内存当中。
3. **init进程**是所有进程的父进程，会接管僵尸进程，如果init无法将僵尸进程删除，只能通过**reboot**的方法抹去进程。
+ 进程的执行顺序（进程的**优先级**）
1. PRI值由**内核动态调整**，用户无法直接调整PRI值，但可以调整nice值
2. nice值
    + root 可调整范围 -20~19
    + 一般用户 可调整范围 0~19
    + nice：**启动命令时**同时设置nice值 `nice -n -5 vim`
    + renice：**已经启动**的进程的nice重新调整 `renice 10 ${PID}`
3. PRI(new) = PRI(old) + nice
+ 检查系统资源
1. free：查看内存使用情况 `free -h` `free -m`
    + buffers：缓冲记忆
    + cached：缓存
    + 物理内存被用光是**正常的**（为了加速访问而将最近访问的数据放在内存），swap最好不要被使用。
2. uname：查看系统与内核相关信息 `uname -a`
3. uptime：查看系统启动时间与工作负载 `uptime`
4. netstat：跟踪网络 `netstat -antupl` `netstat -tlnp`
    + LocalAddress：本地的IP端口情况
    + ForeignAddresss：远程主机的IP端口情况
    + State：连接状态，主要有建立（ESTABLISHED）及监听(LISTEN)
    + Path：连接到**此socket**的相关程序的路径，或者是相关数据输出的路径。
5. dmesg：分析内核产生的信息 `dmesg|more` `dmesg| grep -i hd`  `dmesg |grep -i eth` 
6. vmstat：监测系统资源变化 `vmstat 1 3` `vmstat 5` `vmstat -d`
    + 进程字段procs：
        + r：等待运行中的进程数量
        + b：不可被唤醒的进程数量
        + r和b越大，代表系统越忙碌
    + 内存字段memory：
        + swpd：虚拟内存被使用的大小
        + free：未被使用的内存大小
        + buff：用于缓冲存储器的内存大小
        + cache：用于高速缓存的大小
    + 内存交换空间swap：
        + si：从磁盘进入内存的量
        + so：从内存进入磁盘的量
        + si/so：越大，系统性能越差
    + 磁盘读写io
        + bi：**磁盘写入**内存的**块数量**
        + bo：内存**写入磁盘**的**块数量**
        + 两者值越高，io越忙碌
    + 系统system
        + in：每秒被中断的进程数
        + cs：每秒钟进行的事件切换数
        + 两个数值越大，代表系统与**接口设备**的通信非常频繁，包括磁盘、网卡、时钟等等。
    + CPU
        + us：非内核层的CPU使用状态
        + sy：内核层的CPU使用状态
        + id：闲置的状态
        + wa：等待I/O所耗费的CPU状态
        + st：被**虚拟机**所盗用的CPU的状态
+ /proc/* `cat /proc/${PID}/cmdline` `cat /proc/${PID}/environ`
1. 进程在内存中，内存中数据写入到/proc/* 目录下
2. **cmdline**：启动进程的**命令串**
3. environ：进程的环境变量内容
+ 查询**已打开**文件或**已执行程序打开**的文件
1. fuser：通过**文件（或文件系统）** 找出 **正在使用该文件的程序** `fuser -k /dev/pts/${user_id} 清理终端（停止用户登录）`  `fuser -v`
